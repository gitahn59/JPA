# JPQL

- JPQL은 객체지향 쿼리 언어, 따라서 테이블이 아니라 엔티티를 대상으로 쿼리한다.   
- JPQL은 SQL을 추상화해서 특정 DB의 SQL에 의존하지 않는다.
- JPQL은 결과적으로 SQL로 변환된다.   

## 문법
```sql
select_문 :: =
    select_절
    from_절
    [where_절]
    [groupby_절]
    [having_절]
    [orderby_절]
 
update_문 :: = update_절 [where_절]

delete_문 :: = delete_절 [where_절]
```

JPQL 에서 UPDATE 와 DELETE 를 벌크 연산이라고 한다.  

### SELECT 문
```jpaql
SELECT m FROM Member AS m where m.username = 'Hello'
```

- 대소문자 구분 : 엔티티와 속성은 대소문자를 구분한다. 반면 Select 와 같은 키워드는 구분하지 않는다.
- 엔티티 이름 : JPQL에서 사용한 Member는 클래스 명이 아니라 엔티티 명이다. 이는 @Entity(name="name") 으로 지정할 수 있다.   
- 별칭 필수 : Member AS m 으로 별칭을 지정했다. JPQL 에서는 별칭을 필수로 지정해야 한다.   

### TypeQuery, Query
JPQL 을 실행하려면 쿼리 객체를 생성해야 한다.   
쿼리 객체는 TypeQuery 와 Query 2가지가 있다.   

1. 반환 타입을 지정할 수 있으면 TypeQuery 객체를 사용    
2. 지정할 수 없으면 Query 객체를 사용

```kotlin
val query = em.createQuery("SELECT m FROM Member m", Member::class.java)

val results = query.resultList
for(member in results)
    println(member)
```

em.createQuery 메소드에 클래스를 전달하면 TypeQuery를 반환하고, 전달하지 않으면 Query를 반환한다.   
또는 조회 대상이 여러 개인 경우 반환대상이 불명확해진다.  
이런 경우 JPA는 Object [] 를 리턴하므로 이를 변환해서 사용하면 된다.   

```kotlin
val query = em.createQuery("SELECT m.companyAddress, m.homeAddress FROM Member m")

val results = query.resultList
for(member in results){
    if(member is Array<*>){
        println("${member[0]} ${member[1]}") // smart cast
    }
}
```

> 값 타입은 테이블을 기준으로 분해된 컬럼을 대상으로 하는것이 아니라     
> 객체를 기준으로 값 타입 객체를 대상으로 조회한다

### 결과의 조회
결과 조회는 생성한 query 의 resultList를 가져온다.   
만약 결과가 없다면 빈 컬렉션이 반환된다.   

만약 결과가 정확히 1개일 떄는 query.getSingleResult()를 사용할 수 있다.    
- 결과가 없으면 NoResultException 예외 발생
- 결과가 2개 이상이면 NonUniqueResultException 예외 발생

## 파라미터 바인딩
JPQL은 이름 기준 파라미터 바인딩을 지원한다.   

### 이름 기준 파라미터
이름 기준은 파라미터를 이름으로 구분하는 방법이다.   
이름 기준 파라미터는 이름 앞에 : 를 사용해서 지칭한다.   

```kotlin
val query = em.createQuery(
                    "SELECT m FROM Member m WHERE m.name = :name", Member::class.java)
query.setParameter("name", "alan")
val member = query.singleResult
println("${member.name}")
```
query 에 setParameter 함수를 통해 지정된 이름을 파라미터 값으로 주입할 수 있다.   

### 메소드 체인
JPQL 의 대부분 API는 메소드 체인을 제공하도록 설계되어 있어 연속적으로 작성할 수 있다.   
```kotlin
val member = em.createQuery(
                    "SELECT m FROM Member m WHERE m.name = :name", Member::class.java)
                    .setParameter("name","alan")
                    .singleResult
println("${member.name}")
```

> 위치 기준 파라미터도 사용할 수 있으며 ?1, ?2 방식으로 위치를 표시한다. (:는 사용하지 않음)

> JPQL을 파라미터 바인딩 방식이 아니라 문자를 더해 만들면 SQL 인젝션의 공격 대상이 될 수 있다.

## 프로젝션
SELECT 절에 조회 대상을 지정하는 것을 프로젝션이라고 한다.   
프로젝션 대상은 엔티티, 임베디드 타입, 스칼라(숫자, 문자 등 기본 데이터) 타입이 있다.

### 엔티티 프로젝션
엔티티를 프로젝션 대상으로 사용할 수 있다.
이전 예제에서 SELECT m 은 엔티티 Member를 대상으로 쿼리를 수행했다.   

### 임베디드 타입 프로젝션
임베디드 타입은 프로젝션의 대상이 될 수 있지만, FROM 시작점 대상은 될 수 없다.   
```kotlin
SELECT a FROM Address a 
```
임베디드 타입을 FROM의 시작점으로 사용한 상기 코드는 불가능하다.
임베디드 타입을 조회할 떄는 임베디드 타입을 사용하는 엔티티를 포함한 시작점으로 해야한다.   

> 임베디드 타입은 값 타입이므로 영속성 컨텍스트에 의해 관리되지 않는다.   

### 스칼라 타입 프로젝션
기본 데이터 타입들을 스칼라 타입이라고 한다.   

```jpaql
SELECT name FROM Member m
```

상기 코드를 사용하면 모든 Member의 이름을 죄하여 리스트를 반환한다.   
중복을 제거하려면 sql에서 사용하던 DISTINCT를 그대로 name에 수식해서 사용한다.

> 꼭 필요한 값만 조회하려면 TypeQuery 가 아니라 Query를 리턴 받아 사용해야 한다.

> 만약 여러 값을 함께 조회하여 query 에 여러 Entity 가 들어간다 하더라도,   
> 각 엔티티는 영속성 컨텍스트에 의해 관리된다.   

### NEW 명령어
일부 컬럼을 대상으로 프로젝션해서 타입을 지정할 수 없을 떄는 TypeQuery를 사용할 수 없으며,   
Query를 사용하며 결과값으로 Array<*> 를 반환받았다.   
하지만, 일반적으로 애플리케이션 개발시에는 DTO를 사용할 것이다.   

Array<*>를 반환받아 각각 매핑하지 않고 NEW 키워드를 사용하면 손쉽게 매핑할 수 있다.  

```kotlin
val twoAddress = em.createQuery(
"SELECT NEW com.example.demo.entity.TwoAddress(m.homeAddress, m.companyAddress) FROM Member m WHERE m.name = :name",
        TwoAddress::class.java)
        .setParameter("name","alan")
        .singleResult

println(twoAddress)
```

NEW 키워드와 DTO의 생성자에 필요한 프로퍼티를 전달해서 객체를 생성하듯이 매핑한다.   
1. 패키지 명을 포함한 전체 클래스 명을 입력한다.   
2. 순서와 타입이 일치하는 생성자가 존재해야 한다.   

## 페이징
데이터베이스마다 페이징을 처리하는 SQL 문법이 다르다.   
JPA는 페이징을 위해 두가지 API를 추상화 했다.   
1. setFirstResult(int startPosition) : 조회의 시작 위치(0부터)
2. setMaxResults(int maxResult) : 조회할 데이터의 수

```kotlin
// a 부터 z 로 member를 생성
for(i in 'a'..'z') {
    val member = Member(i.toString(),
            homeAddress = Address("a", "b", "c"),
            companyAddress = Address("d", "e", "f")
    )
    em.persist(member)
}
```

```kotlin
// 페이징 쿼리로 조회
val members = em.createQuery(
        "SELECT m FROM Member m ORDER BY m.name DESC", Member::class.java)
        .setFirstResult(5)
        .setMaxResults(5)
        .resultList

for(member in members){
    println("${member.name}") // f g h i j
} 
// 0부터 시작하므로 5는 f 부터 시작한다
```

상기 예제에서 setFirstResult에 전달된 인덱스는 0을 기준으로 시작한다.
따라서 a b c d e 가 0 부터 4를 차지하므로
5는 f 부터 시작하며, 총 5개의 member를 리턴 받아 j 까지 출력한다

## 집합
집합은 집합 함수를 사용한다.   
1. COUNT : 결과의 수를 구한다. Long
2. MAX, MIN : MAX 값과 MIN 값, 문자, 숫자, 날짜에 사용할 수 있다.   
3. AVG : 평균 값 : 숫자 타입만 사용한다 Double
4. SUM : 합을 구한다 Long, Double, BigInteger, BigDecimal 

- NULL 값은 집계에서 무시된다. (count 가 있어도 무시된다)
- 만약 값이 없는 경우 NULL로 취급한다. COUNT 는 0이 된다   
- DISTINCT를 집합 함수 안세서 사용하면 중복 값을 제거한 후 계산한다
- DISTINCT를 COUNT와 조합해서 사용할 때 임베디드 타입은 지원하지 않는다

## GROUP BY, HAVING
둘은 일반적인 SQL과 그 사용법이 같다.   
GROUP BY는 통계 데이터를 구할 때 특정 그룹으로 묶는다.   
HAVING 은 GROUPY BY로 묶인 그룹을 대상으로 조건을 적용할 때 사용한다.   

## 정렬 (ORDER BY)
결과를 정렬할 떄는 ORDER BY 를 사용한다.   
그 용법은 MYSQL과 같다.   

```jpaql
select m from Member m order by m.age DESC, m.username ASC
```

## 조인
### 내부 조인
내부 조인은 INNER JOIN을 사용하며 INNER 은 생략할 수 있다.   
 

