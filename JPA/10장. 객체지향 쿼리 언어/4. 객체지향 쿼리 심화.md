# rorcpwlgid znjfl tlaghk
## 벌크 연산
데이터를 수정하려면 영속성 컨텍스트의 변경 감지 기능이나 병합을 사용한다.   
그리고 삭제시에는 EntityManager.remove() 를사용한다.   
그러나 이 방법으로 수백 개 이상의 엔티티를 하나씩 처리하기에는 시간이 너무 오래 걸린다.   
이럴 때는 여러건을 한 번에 수정하거나 삭제하는 벌크 연산을 사용한다.   

```kotlin
val result : Int = em.createQuery("""
    update Person p
    set p.age = p.age + 1
    where p.age < :adult
""".trimIndent())
        .setParameter("adult", 19)
        .executeUpdate()
println(result)


val result2 : Int = em.createQuery("""
    delete from Person p
    where p.age < : adult
""".trimIndent())
        .setParameter("adult", 20)
        .executeUpdate()
println(result2)
```

JPQL 조회 쿼리와 마찬가지로 Parameter를 지정할 수 있으며,
executeUpdate 메소드를 마지막에 실행한다.   
리턴 값은 이 쿼리에 영향을 받은 row의 숫자이다.   

> JPA 표준은 아니지만 Hibernate 는 INSER 벌크 연산도 지원한다.

## 벌크 연산의 주의점
벌크 연산은 일반 연산과는 다르게 영속성 컨텍스트를 무시하고 DB에 직접 쿼리한다.   
따라서 벌크 연산을 수행하고, clear 없이 영속성 컨텍스트를 참조한다면,    
영속성 컨텍스트와 DB 사이의 정합성이 맞지 않는다.   
이에 대한 해결책들은 다음과 같다.   

### em.refresh() 사용
벌크 연산을 수행한 후에 상품 A 엔티티를 다시 사용하고 싶다면 refresh 메소드에 엔티티를 전달해서 다시 리로드한다.   

```kotlin
em.refresh(productA)
```

### 벌크 연산 먼저 실행
가장 좋은 해결책은 미리 벌크연산을 수행해두고,    
그 후에 영속성 컨텍스트를 사용하는 것이다.   
이 방법은 JDBC를 JPA와 함깨 사용할 때도 유효하다.   

### 벌크 연산 수행 후 영속성 컨텍스트 초기화   
벌크 연산을 수행한다면 영속성 컨텍스트를 초기화하여    
엔티티를 제거하고 새로 사용하는 것도 좋은 방법이다.   

> 벌크 연산은 영속성 컨텍스트와 2차 캐시를 무시한다.   

## 영속성 컨텍스트와 JPQL
### 쿼리 후 영속 상태인 것과 아닌 것
JPQL 의 조회 대상은 엔티티, 임베디드 타입, 값 타입과 같이 다양하다.  
JPQL로 엔티티를 조회하면 영속성 컨텍스트에 관리되지만, 엔티티가 아니면 관리되지 않는다.   

> 임베디드 타입은 조회에서 값을 변경해도 영속 대상이 아니므로 관리되지 않는다.
> 물론 엔티티를 조회하면 영속 상태가 되어 관리된다.

### JPQL로 조회한 엔티티와 영속성 컨텍스트
컨텍스트에 이미 엔티티가 있는데 같은 엔티티를 조회하면 어떻게 될까?
기존 엔티티를 버리고 새로운 엔티티로 대체할까?   

JPA 에서는 새롭게 조회된 엔티티를 그대로 무시한다.   

> 영속성 컨텍스트는 영속 상태인 엔티티의 동일성을 보장하기 위해 새로 조회된 엔티티를 무시한다.

### find() vs JPQL
em.find() 는 엔티티를 영속성 컨텍스트에서 먼저 탐색한다.   
1차 캐시(영속성 컨텍스트) 를 이용하므로 상황에 따라 매우 신속하게 동작한다.   

반면, JPQL 은 항상 데이터베이스에 SQL 을 실행해서 결과를 조회한다.   
그리고 조회한 결과를 영속성 컨텍스트에 저장한다.   
이때도 역시 앞서 언급한대로 이미 엔티티가 존재하면 조회한 결과를 버리고 기존 엔티티를 돌려준다.   

### JPQL과 플러시 모드
JPA는 플러시가 일어날 때 영속성 컨텍스트에 등록, 수정, 삭제한 엔티티를 찾아서   
각각 INSERT, UPDATE, DELETE SQL을 만들어서 한번에 반영한다.   
플러시를 호출하려면 em.flush() 를 호출하면 되지만, 보통은 플러시 모드에 따라 자동으로 동작시킨다.   

#### 쿼리와 플러시 모드
JPQL은 영속성 컨텍스트에 있는 데이터를 전혀 고려하지 않는다.   
따라서 JPQL을 실행하기 전에 영속성 컨텍스트의 내용을 미리 반영해야 한다.  
그렇지 않으면 의도하지 않은 결과가 발생할 수 있다.   
기본적으로는 flushMode 가 auto 이므로 쿼리 시점에도 flush가 동작한다.   
하지만, flushMode 를 commit으로 설정하면 flush 는 commit 시점에만 동작한다.   

### 플러시 모드 최적화
JPA 쿼리를 사용할 때 flush 여부를 조정할 수 있으므로,    
영속성 컨텍스트에는 있지만, DB에는 없는 데이터를 조회할 수 없다.   
 
> persist 만 수행되고 flush는 수행되지 않은 상태를 말한다.   

이런 상황은 무결성에 심각한 피해를 줄 수 있지만, 플러시가 줄어들수록 성능이 향상된다.   
따라서 이러한 점을 고려하여 성능을 최적화해야 한다.   
