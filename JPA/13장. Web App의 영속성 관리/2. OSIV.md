# 3. OSIV(Open Session in view)

OSIV는 영속성 컨텍스트를 뷰까지 열어둔다는 의미이다.   
영속성 컨텍스트가 살아있으면 엔티티는 영속 상태로 유지된다.   
따라서 뷰에서도 지연 로딩을 사용할 수 있다.   

## 과거 OSIV : 요청 당 트랜잭션

OSIV의 핵심은 뷰에서도 지연 로딩이 가능하도록 하는 것이다.    
가장 단순한 구현은 클라이언트의 요청이 들어오자마자,    
서블릿 필터나 스프링 인터셉터에서 트랜잭션을 시작하고, 요청이 끝날 때 트랜잭션도 끝내는 것이다.   
이러한 방법을 요청 당 OSIV라고 한다.    

요청 -> Filter / Interceptor -> Controller -> Service -> Repository

요청이 들어오자마자 서블릿 필터나 스프링 인터셉터에서 영속성 컨텍스트를 만들면서 트랜잭션을 시작하고,    
요청이 끝날 때 트랜잭션과 영속성 컨텍스트를 함께 종료한다.   
이렇게 하면 영속성 컨텍스트가 처음부터 끝까지 살아있으므로 조회한 엔티티도 영속 상태를 유지한다.   

이제 뷰에서도 지연 로딩을 할 수 있으므로 엔티티를 미리 초기화할 필요도 없다.   

### 요청 당 트랜잭션 방식의 OSIV의 문제점

요청 당 트랜잭션의 가장 큰 문제점은 컨트롤러나 뷰 같은 프리젠테이션 계층이 엔티티를 변경할 수 있다는 점이다.    
예를 들어 마스킹 처리가 필요해서 엔티티에 마스킹 처리를 수행했다고 하자.    
그리고 처리를 종료한 트랜잭션을 커밋한다고 가정해보자.   

트랜잭션을 커밋했으므로 영속성 컨텍스트를 플러시한다.    
이때 영속성 컨텍스트의 변경 감지 기능이 작동해서 변경된 엔티티를 데이터베이스에 반영해버린다.   

비즈니스 로직을 실행하는 곳에서 데이터를 변경하는 것은 당연한 일이다.   
하지만 프리젠테이션 계층에서 데이터를 잠시 변갱했다고 실제 데이터베이스까지 반영되면 그 범위를 알 수 없다.    
이러한 문제를 해결하려면 프리젠테이션 계층에서는 엔티티를 수정하지 못하도록 해야한다.   

* 엔티티를 읽기 전용 인터페이스 제공
* 엔티티 래핑
* DTO 변환

3가지 방법 모두 코드량이 상당히 증가한다.    
따라서 최근에는 이러한 방식을 사용하지 않는다.    
최근에는 이러한 문제점을 보완하여 비즈니스 계층에서만 트랜잭션을 유지하는 OSIV를 사용한다.   
스프링 프레임워크가 제공하는 OSIV가 바로 이러한 방식을 사용한다.    

## 스프링 OSIV: 비즈니스 계층 트랜잭션

스프링 프레임워크가 제공하는 OSIV 라이브러리

스프링 프레임워크의 spring-orm.jar는 다양한 OSIV 클래스를 제공한다.    
OSIV를 서블릿 필터에서 적용할지 스트링 인터셉터에 적용할지에 따라 필요한 클래스를 선택하면된다.    

* 하이버네이트 OSIV 서블릿 필터 : org.springframework.orm.hibernate4.support.OpenSessionInViewFilter
* 하이버네이트 OSIV 스프링 인터셉터 : org.springframework.orm.hibernate4.support.OpenSessionInViewInterceptor
* JPA OSIV 서블릿 필터 : org.springframework.orm.jpa.support.OpenEntityManagerInViewFilter
* JPA OSIV 스프링 인터셉터 : org.springframework.orm.jpa.support.OpenEntityManagerInViewInterceptor

jpa를 사용하면서 서블릿 필터에 OSIV를 적용한다면 OpenEntityManagerFilter를 서블릿 필터에 등록하면 된다.    

### 스프링 OSIV 분석

요청 당 트랜잭션 방식의 OSIV는 프리젠테이션 계층에서 데이터를 변경할 수 있다는 문제점이 있다.    
스프링 프레임워크의 OSIV는 이러한 문제점을 어느정도 해결했다.    
스프링 프레임워크가 제공하는 OSIV는 "비즈니스 계층에서 트랜잭션을 사용하는 OSIV"이다.   
OSIV를 사용하기는 하지만 비즈니스 계층에서만 사용한다는 뜻이다.    

즉 필터 / 컨트롤러 / 뷰에서는 영속 상태이지만 수정은 불가능하고,    
서비스 / 레포지토리에서는 영속 상태이며 수정도 가능한 상태인 것이다.    

클라이언트의 요청이 들어오면 영속성 컨텍스트를 생성한다.   
이때 트랜잭션은 시작하지 않는다.        
서비스 계층에서 트랜잭션을 시작하면 앞에서 생성해둔 영속성 컨텍스트에 트랜잭션을 시작한다.       
비즈니스 로직을 실행하고 서비스 계층이 끝나면 트랜잭션을 커밋하면서 영속성 컨텍스트를 플러시한다.   
이때 트랜잭션만 종료하고 영속성 컨텍스트는 그대로 유지한다.    
이후 클라이언트의 요청이 끝날 때 영속성 컨텍스트를 종료한다.    


1. 클라이언트의 요청이 들어오면 서블릿 필터나, 스프링 인터셉터에서 영속성 컨텍스트를 생성한다.    
2. 서비스 계층에서 @Transactional로 트랜잭션을 시작할 때 1번에서 미리 생성해둔 영속성 컨텍스트를 찾아와서 트랜잭션을 시작한다.    
3. 서비스 계층이 끝나면 트랜잭션을 커밋하고 영속성 컨텍스트를 플러시한다. 이 때 트랜잭션은 끝나지만 영속성 컨텍스트는 여전히 유지된다.    
4. 컨트롤러와 뷰까지 영속성 컨텍스트가 유지되므로 조회한 엔티티는 영속 상태를 유지한다.    
5. 서블릿 필터나, 스프링 인터셉터로 요청이 모두 종료하고 되돌아오면 영속성 컨텍스트를 종료한다. 이 떄는 플러시를 호출하지 않는다.    

### 트랜잭션 없이 읽기

영속성 컨텍스트를 통한 모든 변경은 트랜잭션 안에서 이루어져야 한다.    
만약 트랜잭션 없이 엔티티를 변경하고 영속성 컨텍스트를 플러시하면 javax.persistenct.TransactionRequiredException 예외가 발생한다.   
엔티티를 변경하지 않고 단순히 조회만 할 떄는 트랜잭션이 없어도 되는데 이것을 트랜잭션 없이 읽기(Nontransactional reads)라 한다.   
프록시를 초기화하는 지연 로딩도 조회 기능이기 때문에 트랜잭션 없이도 읽기가 가능하다.   

* 영속성 컨텍스트는 트랜잭션 범위 안에서 엔티티를 조회하고 수정할 수 있다.    
* 영속성 컨텍스트는 트랜잭션 범위 밖에서 엔티티를 조회만 할 수 있다. 이를 트랜잭션 없이 읽기(Nontransactional reads)라 한다.    

스프링이 제공하는 OSIV를 활용하면 프리젠테이션 계층에서는 트랜잭션이 없으므로 엔티티를 수정할 수 없다.    
또한 트랜잭션 없이 읽기를 지원하기 때문에 지연로딩이 잘 동작환다.    

* 영속성 컨텍스트를 프리젠테이션 계층까지 유지한다.    
* 프리젠테이션 계층에는 트랜잭션이 없으므로 엔티티를 수정할 수 없다.    
* 프리젠테이션 계층에는 트랜잭션이 없지만 트랜잭션 없이 읽기를 사용해서 지연 로딩을 할 수 있다.    

> 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영하려면 영속성 컨텍스트를 플러시해야 한다.    
> 하지만 트랜잭션을 사용하는 서비스 계층이 끝날 때 트랜잭션이 커밋되면서 이미 플러시한다.   
> 스프링이 제공하는 OSIV 기능은 필터나 인터셉터에서 요청이 종료되면 플러시를 호출하지 않고 em.close()로 영속성 컨텍스트를 종료한다.    
> 프리젠테이션 계층에서 em.flush()를 호출해서 강제로 플러시하더라도 트랜잭션 범위 밖이기 때문에 데이터를 수정할 수 없다는 에러를 던진다.   
> javax.persistence.TransactionRequiredExcpetion : no transaction is in progresss

### 주의사항

스프링 OSIV를 사용하면 프리젠테이션 계층에서 엔티티를 수정해도 수정 내용을 데이터베이스에 반영하지 않는다.   
그런데 여기에는 예외 사항이 있다.   
프리젠테이션 계층에서 엔티티를 수정한 후 트랜잭션을 시작하는 서비스 계층을 다시 호출한다면 문제가 발생한다.   

1. 프리젠테이션 계층에서 엔티티를 수정했다.   
2. 비즈니스 로직의 트랜잭션 A를 시작하고 종료한다.   
3. 트랜잭션 A에서 엔티티의 변경을 감지하고 엔티티의 수정사항을 데이터베이스에 반영한다.    

컨트롤러에서 엔티티를 수정하고 즉시 뷰를 호출하는 것이 아니라    
트랜잭션이 동작하는 비즈니스 로직을 호출하여 이러한 문제가 발생한다.    
문제를 해결하는 단순한 방법은 트랜잭션이 있는 비즈니스 로직을 모두 호출하고 나서 엔티티를 변경하면 된다.    

스프링 OSIV는 같은 영속성 컨텍스트를 여러 트랜잭션이 공유할 수 있으므로 이러한 문제가 발생한다.    
OSIV를 사용하지 않는 트랜잭션 범위의 영속성 컨텍스트 전략은 트랜잭션의 생명주기와 영속성 컨텍스트의    
생명주기가 같으므로 이러한 문제가 발생하지 않는다.    

## OSIV 정리

* OSIV는 클라이언트의 요청이 들어올 떄 영속성 컨텍스트를 생성하고, 요청이 끝날 때까지 유지한다.   
  따라서 한 번 조회한 엔티티는 요청이 끝날 때까지 영속상태를 유지한다.
* 엔티티 수정은 트랜잭션이 있는 계층에서만 동작한다.   
  트랜잭션이 없는 프리젠테이션 계층은 지연 로딩을 포함해서 조회만 할 수 있다.

* OSIV를 사용하면 같은 영속성 컨텍스트를 여러 트랜잭션이 공유할 수 있다.   
 특히 트랜잭션 롤백 시 주의해야 한다.    
* 프리젠테이션 계층에서 엔티티를 수정하고 다시 비즈니스 로직을 수행하면 엔티티가 수정될 수 있다.    
* 프레젠테이션 계층에서 지연 로딩에 의한 SQL이 실행된다. 이는 성능 튜닝시 확인해야 하는 부분이다.    

## OSIV vs FACADE vs DTO

OSIV를 사용하지 않는 대안은 FACADE 계층을 사용하는 것이다.    
어떠한 방법을 사용하든 결국 준영속 상태가 되기 전에 프록시를 초기화해야 한다.   
다른 방법은 엔티티를 직접 노출하지 않고 엔티티와 거의 비슷한 DTO를 반환해야 한다.    

OSIV를 사용하는 방법이 만능은 아니다.   
OSIV를 사용하면 화면을 출력할 떄 엔티티를 유지하면서 객체 그래프를 마음껏 탐색할 수 있다.   
하지만 JVM을 벗어난 원격 상화에서는 사용할 수 없다.    

