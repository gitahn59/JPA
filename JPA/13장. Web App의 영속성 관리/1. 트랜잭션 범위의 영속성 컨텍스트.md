# 웹 애플리케이션과 영속성 관리

## 1. 트랜잭션 범위위 영속성 컨텍스트

스프링을 사용하는 환경에서 JPA를 사용하려면 컨테이너의 전략을 따라야 한다.   

### 스프링 컨테이너 기본 전략

스프링 컨테이너에서는 트랜잭션 범위의 영속성 컨텍스트 전략을 기본으로 사용한다.   
이 전략은 이름 그대로 트랜잭션의 범위와 영속성 컨텍스트의 범위가 같다는 뜻이다.

> 트랜잭션 범위 = 영속성 컨텍스트의 생명 주기   
> 같은 트랜잭션 안에서는 같은 영속성 컨텍스트에 접근

스프링 프레임워크를 사용하면 보통 비즈니스 로직을 시작하는 서비스 계층에 @Transactional 어노테이션을 선언한다.   
스프링 트랜잭션 AOP는 대상 메소드를 호출하기 직전에 트랜잭션을 시작하고,   
메소드가 종료되면 트랜잭션을 커밋하고 종료한다.   

스프링 트랜잭션 AOP는 대상 메소드를 호출하기 직전에 트랜잭션을 시작하고,    
대상 메소드가 정상 종료되면 트랜잭션을 커밋하면서 종료한다.   

이떄 트랜잭션을 커밋하면 JPA는 먼저 영속성 컨텍스트를 플러시해서,    
변경 내용을 데이터베이스에 반영한 후에 데이터베이스 트랜잭션을 커밋한다.    
따라서 영속성 컨텍스트의 변경 내용이 데이터베이스에 정상 반영된다.    

예외가 발생하는 경우에는 트랜잭션을 롤백하고 종료하는데 이때는 플러시를 호출하지 않는다.   
 
#### 트랜잭션이 같으면 같은 영속성 컨텍스트를 사용

트랜잭션 범위의 영속성 컨텍스트 전략은 다양한 위치에서 매니저를 주입받아 사용해도,   
트랜잭션이 같으면 항상 같은 컨텍스트를 사용한다.   

> 서로 다른 Repository 를 사용하더라도 같은 컨텍스트를 사용한다는 의미이다.

#### 트랜잭션이 다르면 다른 영속성 컨텍스트를 사용

> 트랜잭션 범위가 다르면 같은 Repository 를 사용하더라도 다른 컨텍스트를 사용한다.   

스프링 컨에이너는 스레드마다 각각 다른 트랜잭션을 할당한다.   
따라서 같은 엔티티 매니저를 호출해도 접근하는 영속성 컨텍스트가 다르므로 멀티스레드 상황에서도 안전하다.   

## 2. 준영속 상태와 지연 로딩

트랜잭션은 보통 서비스 계층에서 시작한다.   
따라서 서비스 계층이 끝나는 시점에 트랜잭션이 종료되며 영속성 컨텍스트도 함께 종료된다.
따라서 서비스 바깥인 컨트롤러나 뷰 계층에서는 준영속 상태가 된다는 말이다.   

```kotlin
@Entity
class Order{
    @ManyToOne(fetch = FetchType.LAZY) // 지연 로딩
    val member : Member
}
```

상기 예제를 보면 Order 엔티티는 Member를     
지연 로딩 전략을 사용해서 필요한 시점에 가져온다.   
컨테이너 환경의 기본 전략인 트랜잭션 범위의 영속성 컨텍스트 전략에 따라   
트랜잭션이 없는 프리젠테이션 계층에서 엔티티는 준영속 상태가 된다.   

따라서 변경 감지와 지연 로딩이 동작하지 않는다.   
이에 따라 지연 로딩 시점에 예외가 발생하게 된다.   

### 준영속 상태와 변경 감지

변경 감지 기능은 서비스 계층에서 비즈니스 로직을 수행하면서 발생한다.   
오히려 변경 감지 기능이 프리젠테이션 계층에서 동작하면 책임이 모호해진다.   
또한 데이터를 어디서 어떻게 변경했는지 다 찾아야 하므로 유지보수가 어렵다.   

### 준영속 상태와 지연 로딩

준영속 상태의 문제는 지연 로딩이 불가능하다는 점이다.   
뷰를 렌더링할 때 연관된 엔티티도 사용해야 하는데 지연 로딩으로     
설정해 프록시 객체를 조회했다고 가정하자.    
아직 초기화되지 않은 프록시 객체를 사용하면 실제 데이터를 불러올 때 초기화를 시도한다.   
이 때 영속성 컨텍스트가 없으므로 지연 로딩을 할 수 없어 LazyInitializationException 예외가 발생한다.   

이에 대한 해결 방법을 크게 2가지다.

- 필요한 엔티티를 미리 로딩
1. 글로벌 페치 전략 수정
2. JPQL fetch 조인
3. 강제로 초기화
- OSIV를 사용해 엔티티를 항상 영속 상태로 유지

### 사전 로딩 : (1) 글로벌 페치 전략 수정

글로벌 페치 전략이란 Entity 를 정의할 때 지정한 전략을 의미한다.   
여기서 설정한 전략에 따라 모든 위치에서 그 전략이 동작하기 때문에     
글로벌 페치 전략이라고 불린다.       

> 따라서 가장 손쉬운 방법은 FetchType.EAGER 로 수정하는 것이다.

#### 글로벌 페치 전략에서 즉시 로딩 사용의 단점

- 사용하지 않는 엔티티까지 로딩한다.
- N+1 문제가 발생한다.
 JPA를 사용하면서 성능상 가장 조심해야 하는 점이 바로 N + 1 문제이다.
  
N + 1 문제가 발생하는 이유는 EAGER를 확인하면 식별자를 기준으로    
또는 대외키를 기준으로 연관된 엔티티를 조회하기 위해    
DB를 조회하기 때문이다.   

##### N + 1 문제

em.find() 메소드로 엔티티를 조회할 때 로딩 전략이 즉시 로딩이면    
데이터베이스에 JOIN 쿼리를 사용해서 한 번에 연관된 엔티티까지 조회한다.   
실행된 SQL을 보면 즉시 로딩으로 설정한 엔티티까지 Join 쿼리로 함께 가져온다.   

하지만 문제는 JPQL을 사용할 때 발생한다.  

```jpaql
select o from Order o
```

```sql
select * from Order
```

JPA는 JPQL을 분석해서 SQL을 생성할 때 글로벌 패치 전략을 고려하지 않고 단지 JPQL 자체만 사용한다.   
따라서 즉시 로딩이나 지연 로딩을 구분하지 않고 JPQL 쿼리 자체를 sql로 변환하는 것만 생각한다.   
따라서 코드 내부는 다음 순서로 동작한다.

1. JPQL을 분석해 SQL을 생성한다.
2. 데이터베이스에서 결과를 받아 엔티티들을 생성한다.
3. 글로벌 페치 전략이 즉시 로딩이므로 연관된 엔티티도 즉시 로딩한다.
4. 연관된 엔티티를 영속성 컨텍스트에서 일단 찾아본다. 
5. 영속성 컨텍스트에 없으면 SELECT * FROM 연관_ENTITY id = ? 를 엔티티를 조회한 수만큼 실행한다.

이처럼 조회한 데이터 수만큼 다시 SQL을 추가적으로 사용해서 조회하는 것을 N + 1 문제라고 한다.   
N + 1 이 발생하면 sql 이 상당히 많이 호출되어 조회 성능에 치명적이다.   

> 이러한 문제는 JPQL 페치 조인으로 해결한다.

### 사전 로딩 : (2) JPQL 페치 조인

글로벌 페치 전략을 즉시 로딩으로 설정하면 애플리케이션 전체에 영향을 미치므로 비효율적이다.   
JPQL을 호출하는 시점에 함께 로딩할 엔티티를 선택할 수 있는 페치 조인을 알아보자.   

```sql
select o from Order o
select * from Order
```

```jpaql
select o from Order o join fetch o.member
```

```sql
select o.*, m.* 
from Order o 
    join Member m on o.MMEMBER_ID = m.MEMBER_ID
```
패치 조인은 조인을 추가하고 마지막에 fetch를 넣어주면 된다.   
페치 조인을 사용하면 SQL JOIN을 사용해서 패치 조인 대상까지 함께 조회하며, 
N + 1 문제가 발생하지 않는다.   
페치 조인은 N + 1 문제를 해결하면서 엔티티를 미리 로딩하는 현실적인 방법이다.   

#### JPQL 페치 조인의 단점

페치 조인을 무분별하게 사용하면 다른 계층에 종속된 리포지토리 메소드가 증가하며,   
데이터 접근 계층을 침범하게 된다.   
따라서 적절한 타협이 필요하다.   

### 사전 로딩 : (3) 강제로 초기화

강제로 초기화는 영속성 컨텍스트가 살아있는 시점에 프리젠테이션 계층이 필요한 엔티티를 강제로 초기화해서 반환받아두는 방법이다.
Hibernate.initialize() 메소드를 사용하면 프록시를 강제로 초기화할 수 있다.   

### FACADE 계층 추가

> 퍼사드 패턴    
> 복잡한 서브클래스들의 인스턴스를 가지고 있어서,    
> 복잡한 호출 방식의 처리를 담당하는 클래스

뷰를 위해 프록시를 초기화하기 위해 서비스 계층과 프리젠테이션 계층 사이에 FACADE 계층을 추가한다.   
그리고 FACADE 계층에서 트랜잭션을 시작하도록 바꾸어 영속성 컨텍스트의 생명 주기를 관리한다.   
그리고 프록시의 초기화를 담당하도록 하여 필요한 엔티티를 로딩한다.   

1. 프리젠테이션 계층과 도메인 모델 계층 간 논리적 의존성 분리
2. 프리젠테이션 계층에서 필요한 프록시 객체를 초기화
3. 서비스 계층을 호출해서 비즈니스 로직 실행
4. 리포지토리를 직접 호출해서 뷰가 요구하는 엔티티 탐색

### 정리

모든 문제는 엔티티가 트랜잭션 밖에서 준영속 상태이기 때문에 발생한다.   
이를 해결하려면 OSIV를 사용한다.  




