# 영속성 관리
## 6. 준영속
영속 상태의 엔티티가 영속성 컨텍스트에서 분리된 것을 준영속 상태라고 한다.   
준영속 엔티티는 영속성 컨텍스트가 제공하는 기능을 사용할 수 없다.

### 준영속 상태로 만드는 방법
1. em.detach(entity) : 특정 엔티티를 준영속 상태로 전환한다.
2. em.clear() : 영속성 컨텍스트를 완전히 초기화한다.
3. em.close() : 영속성 컨텍스트를 종료한다. 

### detach()
detach는 특정 엔티티를 준영속 상태로 변경한다.   
이 메소드를 수행하면 1차 캐시, 쓰기 지연 SQL 저장소까지 해당 엔티티를 관리하는 정보가 제거된다.   
이렇게 준영속 상태가 되면 데이터 베이스에 저장되지도 않는다.   

### clear()
em.clear()는 영속성 컨텍스트를 초기화해서 해당 컨텍스트가 관리하는 모든 엔티티를 준영속 상태로 만든다.
이는 영속성 컨텍스트를 제거하고 새로 만든 것과 같다.   
준영속 상태가 되면 변경 감지 기능이 동작하지 않고, 데이터베이스에 동기화되지도 않는다.   

### close()
영속성 컨텍스트를 종료하면 해당 컨텍스트가 관리하던 모든 엔티티가 준영속 상태가 된다.

### 준영속 상태의 특징
#### 거의 비영속 상태와 비슷하다.
영속성 컨텍스트가 관리하지 않으므로 1차 캐시, 쓰기 지연, 변경 감지, 지연 로딩을 포함한   
어떤 기능도 동작하지 않는다.

#### 식별자 값을 여전히 가지고 있다.   
준영속 상태는 비영속 상태와 다르게 이미 영속 상태였으므로 식별자 값을 가지고 있다.  

#### 지연 로딩을 할 수 없다.   
지연 로딩은 실제 객체 대신 프록시를 미리 로딩해 두고   
사용 시점에 영속성 컨텍스트를 통해 데이터를 불러오는 방법이다.   
하지만 준영속 상태의 엔티티는 더이상 관리되지 않으므로 지연 로딩 시 문제가 발생한다.

### 병합 : merge()
준영속 상태의 엔티티를 다시 영속 상태로 변경하려면 병합을 사용한다.   
merge()는 엔티티를 받아 새로운 영속 상태의 엔티티를 반환한다.   

> 새로운 엔티티의 참조가 반환된다.
> 기존에 merge로 전달한 엔티티는 그대로 준영속 상태이고   
> 기존 엔티티의 값을 가진 새로운 영속상태의 엔티티가 반환되는 것이다.   

병합은 비영속 엔티티도 영속 상태로 만들 수 있다.   
비영속 엔티티는 DB에도 엔티티가 존재하지 않으므로 새롭게 생성된다.
따라서 병합은 save 또는 update를 사용한다고 볼 수 있다.s

### 영속 여부 확인 : contains(entity)
```kotlin
em.contains(entity)
```

contains 메소드를 사용하면 엔티티의 영속 여부를 확인할 수 있다.

