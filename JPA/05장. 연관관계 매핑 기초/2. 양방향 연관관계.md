# 양방향 연관관계

## 3. 양방향 연관관계

기존에는 회원에서 팀으로만 향하는 단방향 연관관계로 구성된 엔티티를 사용했다.   
여기에 팀에서 회원으로 향하는 단방향 연관관계를 추가하면   
팀과 회원은 엔티티 사이에서도 양방향 연관관계를 가질 수 있다.   

회원과 팀은 N:1 관계를 가지고 있으며 팀을 기준으로 보면 1:N 관계를 가지고있다.   
N:1 관계는 기존 엔티티에서는 @ManyToOne으로 나타내었으며 참조 변수를 1개 가지고 있었다.   
1:N 관계는 @OneToMan로 나타내며 참조 변수 컬렉션으로 나타내야 한다.   

> JPA는 List, Collection, Set, Map 을 지원한다.   

데이터베이스 테이블은 외래 키 하나로 양방향으로 조회할 수 있다.  
따라서 별도로 데이터베이스에서 추가할 내용은 없다.   

### 양방향 연관관계 매핑

```kotlin
@Entity
class Member(
        @Id
        @Column(name="MEMBER_ID")
        var id : String,
        var username : String,
        @ManyToOne
        @JoinColumn(name="TEAM_ID")
        var team : Team?
)
```

```kotlin
@Entity
class Team(
        @Id
        @Column(name="TEAM_ID")
        var id : String,
        var name : String,
        @OneToMany(mappedBy = "team")
        val members : List<Member> = arrayListOf<Member>()
)
```

팀의 경우 회원을 참조하기 위한 새로운 프로퍼티가 추가되었다.   
@OneToMany로 연관관계의 다중도를 나타내며 mappedBy 로 어떤 프로퍼티와 연결되는지 나타낸다.   
이 경우 Member.team과 연결되므로 team을 사용했다.   

```kotlin
val team = em.find(Team::class.java, "team1")
val members = team.members

for(member in members){
    println(member.username)
}
```

객체 그래프를 탐색하면 회원들을 참조할 수 있다.  

## 4. 연관관계의 주인

@OneToMany에는 mappedBy라는 속성이 있다.   
객체에서는 사실 양방향 관계가 존재하지 않고, 서로를 단방향 연관관계로 엮어 양방향 관계처럼 보이게 만든다.   
그러다보니 객체의 참조는 둘인데 테이블에서 외래 키는 하나인 차이가 발생한다.   

이런 차이로 인해 JPA는 두 객체 연관관계 중 하나를 정해 테이블의 외래 키를 관리하게 하는데    
이를 연관관계의 주인이라고 한다.   

### 양방향 매핑의 규칙 : 연관관계의 주인

매핑 시 연관관계 중 하나를 주인으로 정해야 한다.   
연관관계의 주인은 DB의 연관관계와 매핑되고, 키를 관리(등록, 수정, 삭제) 할 수 있다.   
반면 주인이 아닌쪽은 키를 읽기만 할 수 있다.   

연관관계의 주인을 정하는 방법은 mappedBy 속성을 사용한다.   
- 주인은 mappedBy 속성을 사용하지 않는다.
- 주인이 아니면 mappedBy 속성에 주인을 지정한다.   

연관관계의 주인은 항상 N 쪽이 가져간다.  
물리적으로 N 쪽이 외래키를 테이블에 저장하고 있기 때문이다.

만약, 1 쪽이 주인이 된다면 자신의 테이블에 없는 키를 관리하게 되는 모순이 발생한다.   

따라서 예제에서는 Member가 주인으로 설정되었고,   
Team은 mappedBy 로 연관관계의 외래키인 Member의 team 필드를 가리킨다.   

> 연관관계의 주인만 데이터베이스 연관관계와 매핑되고 외래키를 관리할 수 있다.
> 주인이 아닌쪽은 읽기만 가능하고 외래키를 변경하지 못한다.   
> @ManyToOne은 항상 주인이 되므로 mappedBy 속성이 없다.   

## 5. 양방향 연관관계의 주의점
### 연관관계는 주인쪽에 저장해야 한다

연관관계를 주인쪽이 아니라 반대쪽에 저장하는 경우, 외래키가 관리되지 않는다.   
따라서 영속성 컨텍스트를 커밋하고 플러시해도 데이터베이스에 그 관계는 반영되지 않는다.   

> 반드시 주인쪽에서 연관관계를 저장하고 커밋해야 한다.

### 영속성 컨텍스트의 생명주기를 고려해야 한다.  

주인 쪽에만 연관관계를 저장하고 그대로 영속성 컨텍스트를 공유해서 사용한다면 오류가 발생한다.   
테이블 상에는 문제가 없지만 객체 상에서는 아직 영속성 컨텍스트가 종료되지 않아   
연관관계가 새로 업데이트되지 않았기 때문이다.   

따라서 연관관계가 정상적으로 반영된 엔티티를 사용하고 싶다면,   
1. 영속성 컨텍스트를 새로 생성해서 새롭게 엔티티를 받아와야 한다.
2. 객체 상에서 주인이 아닌쪽에도 연결 관계를 추가해 주어야 한다.

1번 해결법은 영속성 컨텍스트를 초기화하면 해결된다.   
2번 해결법은 연관관계 편의 메소드 라는 기법을 사용한다.

### 연관관계 편의 메소드
이 메소드는 setter에 참조 관계를 명시적으로 추가해    
객체 간의 참조 관계를 테이블의 참조관계와 일치시키는 방법이다.

```kotlin
val team : Team
set(value){
    field = value // 주인을 위한 참조관계 지정
    field.members.add(this) // 참조관계를 추가적으로 집어넣어
                            // 동기화한다
}
```

이렇게 setter를 지정하면 실수 없이 같은 영속성 컨텍스트 내에서 양방향 참조관계를
손쉽게 지정할 수 있다.   

상기 코드에는 아직 문제점이 남아있다.   
같은 컨텍스트 내에서 다시 한번 주인쪽의 참조 관계를 변경한다면,  
주인이 아닌 엔티티에 여전히 참조 관계가 남아있다는 점이다.   

따라서 참조 관계가 변경되는 시점에 주인이 아닌쪽의 참조 관계를 제거하는 기능이 필요하다.

```kotlin
set(value){
    if(field != null){
        field.members.remove(this)
    }

    field = value 
    field.members.add(this) 

}
```

주인이 아닌 엔티티인 members 에서 현재 회원 정보를 제거한 하고, 새롭게 등록한다.

### 무한 루프

상기 예제에서 Member.toString()을 호출하여 내부적으로 getTeam()을 호출하고,  
다시 getTeam()으로 호출된 team에서 members로 다시 getMember()를 호출하여,   
서로 물고 무는 무한 루프에 빠질 수 있다.   

이는 JSON으로 변환할 때 주로 발생한다.   
JSON 라이브러리들은 이를 방지하기 위해 어노테이션이나 기능을 제공한다.   






   
 
