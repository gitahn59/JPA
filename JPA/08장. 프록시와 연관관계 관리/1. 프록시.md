# 프록시
## 1. 프록시

엔티티를 조회할 때 연관된 엔티티들이 항상 같이 사용되지는 않는다.  
비즈니스 로직에 따라 일부 엔티티만 사용하는 경우가 생길 수 있으며,   
이런 상황에는 필요한 엔티티만 로딩하는 것이 효율적이다.   

> JPA 는 이런 비효율성을 해결하기 위해 실제 사용될 때까지 DB 조회를 지연시키는 지연 로딩을 지원한다.

지연 로딩을 가능하게 하려면 실제 엔티티 대신 가짜 객체를 임시로 할당할 필요가 있는대,   
이를 프록시 라고 한다.   

> JPA 명세는 지연 로딩의 구현을 JPA 구현체에 위임했다.   
> 따라서 앞으로 언급되는 내용은 하이버네이트 구현체의 내용이다.  

### 프록시 기초
JPA에서는 식별자로 엔티티 하나를 조회할 떄는 find() 를 사용한다.   
영속성 컨텍스트에 엔티티가 없으면 DB를 조회해서 가져온다.   

```kotlin
val member = em.find(Member::class.java, "member1")
```

엔티티를 직접 조회하면 엔티티를 사용하던 안하던 DB를 조회하게 된다.   
엔티티를 실제 사용하는 시점까지 조회를 미루고 싶다면 getReference() 메소드를 사용하면 된다.   

```kotlin
val member = em.getReference(Member::class.java, "member1")
```

이 메소드를 호출하면 JPA는 데이터베이스를 조회하지 않고 엔티티를 생성하지도 않는다.   
대신 DB 접근을 위임한 프록시 객체를 반환한다.   

프록시 클래스는 실제 클래스를 상속 받는다.   
실제 클래스와 인터페이스가 같으며 사용자는 이 객체가 진짜인지 프록시인지 구분하지 않고 사용할 수 있다.   

프록시 객체는 실제 객체에 대한 참조를 보관하고 있다가, 프록시 객체의 메소드를 호출하면 프록시 객체는 실제 객체의 메소드를 호출한다.   

### 프록시 초기화
프록시 객체는 member.getName() 처럼 실제 사용될 때    
데이터베이스를 조회해서 실제 엔티티 객체를 생성하는데 이를 프록시 객체의 초기화라 한다.

> 영속성 컨텍스트에 이미 엔티티가 존재하면 getReference()를 호출해도 실제 엔티티를 반환한다.      
> 초기화는 영속성 컨텍스트의 도움을 받아야 가능하다.   
> 따라서 준영속 상태의 프록시를 초기화하면 LazyInitializationException 이 발생한다.   

### 프록시와 식별자

엔티티에 대한 프록시를 생성할 때 프록시는 식별자 값을 보관한다.   
따라서 식별자 값을 조회하는 접근자를 호출하면 프록시를 호출하지 않고 보관해둔 식별자 값을 돌려준다.   

> 엔티티 접근 방식이 프로퍼티로 설정한 경우에만 초기화하지 않는다.   
> 엔티티 접근 방식이 필드라면 내부 구현을 알 수 없으므로 JPA는 프록시 객체를 초기화한다.   

이러한 프록시의 특징은 연관관계를 설정할 때 유용하게 사용할 수 있다.   

```kotlin
val member = em.find(Member::class.java, "member1")
val team = em.getReference(Team::class.java, "team1")

member.team = team
```

> 연관관계를 설정할 때는 식별자 값만 사용하므로 프록시를 사용하면 DB 접근 횟수를 줄일 수 있다.   

### 프록시 확인

```java
PersistenceUnitUtil.isLoaded(Object entity)
```
isLoaded 메소드를 사용하면 프록시 인스턴스의 초기화 여부를 확인할 수 있다.
또한 getClass 로 클래스명을 출력해보면 ..javasist.. 가 붙어 있으므로 이를 통해서도 확인해 볼 수 있다.   


## 2. 즉시 로딩과 지연 로딩
프록시 객체는 주로 연관된 엔티티를 지연 로딩할 때 사용한다.   

member1 이 team1 에 소속해 있다고 가정하자.   
회원 엔티티를 조회하면서 team도 같이 조회하는 것보다, team은 실제 사용시점에 조회하는 것이 효율적일 것이다.
JPA는 이에 대한 해결책을 제공한다.

### 즉시 로딩(Eager Loading)
즉시 로딩을 사용하려면 @ManyToOne 의 fetch 속성을 FetchType.EAGER 로 지정한다.   
```kotlin
@ManyToOne(fetch = FetchType.EAGER)
```

즉시 로딩을 설정하면 엔티티를 조회하는 순간 연관된 엔티티도 함깨 조회하여 영속성 컨텍스트에 저장한다.   
이 때 각 엔티티마다 조회 쿼리를 사용하지 않고 JOIN을 통해 쿼리 1번으로 두 엔티티를 한꺼번에 조회한다.

```kotlin
val member = it.find(Member::class.java, 1L)
val team = member.team
```

```sql
select member0_.member_id as member_i1_0_0_, member0_.age as age2_0_0_, 
       member0_.name as name3_0_0_, member0_.team_id as team_id4_0_0_, 
       team1_.team_id as team_id1_2_1_, team1_.name as name2_2_1_ 
from member member0_ 
    left outer join team team1_ 
        on member0_.team_id=team1_.team_id 
where member0_.member_id=?
```

> NULL 제약조건과 JPA 조인 전략   
> 외래 키 관계가 NULL ABLE 이면 내부 조인을 사용할 때 조회되지 못하는 엔티티가 발생한다.   
> 따라서 이 경우에는 JPA는 외부 조인을 사용해서 누락되는 엔티티가 없도록 조회한다.   
> 하지만 외부 조인은 내부 조인에 비하여 성능이 나쁘다.   

> 즉시 로딩을 내부 조인으로 동작시키는 방
> 1. nullable 설정을 false로 변경하여 null 제약조건을 추가한다.
> 2. @ManyToOne.optional = false 로 설정한다.

JPA는 선택적 관계면 외부 조인을 사용해서 누락을 없애고       
필수 관계면 누락 없음이 보장되므로 내부 조인을 사용한다.   

### 지연 로딩
지연 로딩을 사용하려면 @ManyToOne의 fetch 속성을 FetchType.LAZY 로 지정한다.   
```kotlin
@ManyToOne(fetch = FetchType.LAZY)
```

지연 로딩을 사용하면 회원만 조회하고 팀은 조회하지 않는다.   
대신에 조회한 회원의 team 멤버에는 프록시 객체를 넣어둔다.   

```kotlin
val team = it.find(Team::class.java, 1L)
```

지연 로딩을 사용하면 join을 사용하지 않고 그 엔티티만 가져온다.

```sql
select team0_.team_id as team_id1_2_0_, team0_.name as name2_2_0_ 
from team team0_ 
where team0_.team_id=?
```

반환된 팀 객체는 프록시 객체로, 실제 사용 시점까지 데이터 로딩을 미룬다.   

> 조회 대상이 이미 영속성 컨텍스트에 있다면 프록시 객체를 사용할 필요가 없다.   
> 따라서 지연 로딩을 설정하더라도 컨텍스트로부터 실제 객체를 받아온다.

### 정리
처음부터 모든 엔티티를 영속성 컨텍스트에 올리는것은 비현실적이고,   
반대로 필요할 때마다 SQL을 실행해서 그때그때 로딩하는 것도 비효율적일 수 있다.   

대부분의 비즈니스 로직에서 회원과 팀을 같이 사용한다면 SQL 조인으로 한꺼번에 조회하는 것이 효율적이다.   

## 3. 지연 로딩의 활용
### 프록시와 컬렉션 래퍼

1. 즉시 로딩은 실선으로 표현
2. 지연 로딩을 점선으로 표현

하이버네티트는 엔티티를 영속 상태로 만들 때 엔티티에 컬렉션이 있으면   
컬렉션을 관리할 목적으로 원본 컬렉션을 하이버네이트가 제공하는 내장 컬렉션으로 변경한다.   

> 이를 컬렉션 래퍼라고 한다   
> org.hibernate.collection.internal.PersistentBag   

엔티티를 지연 로딩하면 프록시 객체가 이를 지연 로딩하지만,   
컬렉션은 컬렉션 래퍼가 지연 로딩을 처리한다.   

getCollections() 처럼 컬렉션을 부르는 시점에 지연 로딩이 되는 것이 아니라,   
getCollections().get(0) 처럼 실제 컬렉션에서 데이터를 조회할 때 초기화가 일어난다.   

### 기본 전략
@ManyToOne, @OneToOne : 즉시 로딩   
@OneToMany, @ManyToMany : 지연 로딩

JPA는 기본 전략으로 연관 엔티티가 1개이면 즉시 로딩을 수행하고,   
컬렉션이면 지연 로딩을 사용한다.   

컬렉션은 비용이 많이 들고 너무 많은 연관 엔티티를 로딩할 수 있기 때문이다.   

> 기본적으로 지연 로딩으로 프로그램을 개발하고, 분석 단계에서 꼭 필요한 곳에만 즉시 로딩을 사용하도록 최적화한다.  
> 다만, 이러한 과정은 SQL 을 사용하게 되면 변경이 어렵다.  

### 주의점
#### 컬렉션을 하나 이상 즉시 로딩하는 것은 권장하지 않음
컬렉션과 조인한다는 것은 Table을 기준으로 보면 일대다 조인이 수행된다.   
일대다 조인은 결과 데이터가 다 쪽에 있는 수만큼 급격하게 결과가 증가한다.   

서로 다른 컬렉션을 2개 이상 조인하게되면 N * M 개의 row 가 반환되면서 성능이 급격하게 저하된다.   

#### 컬렉션 즉시 로딩은 항상 외부 조인을 사용한다.   
회원 테이블과 팀 테이블을 조인(N:1)할 때, 
회원 테이블의 외래 키가 not null 이라면 모든 회원은 항상 팀에 소속된다.
따라서 회원 테이블을 기준으로 내부 조인을 수행하면 누락되는 엔티티가 없다

반면 팀 테이블에서 회원 테이블을 향해 일대다(1:N) 관계를 조인할 때,   
회원이 한 명도 없는 팀을 내부 조인하면 팀까지 덩달아 조회되지 않는 문제가 발생한다.   
(내부 조인은 공통 조건이 있는 엔티티와 엔티티를 조인하여 결과 행을 생성함)

데이터베이스의 제약조건으로는 이를 막을 수 없으며, JPA 는 일대다 관계를 즉시 로딩할 때는 항상 외부 조인을 사용한다.   

@ManyToOne, @OneToOne
- optional = false : 내부 조인 : not null 인 경우 적용 가능하며 설정 필요
- optional = true : 외부 조인 (default)

@OneToMany, @ManyToMany
- optional 설정에 상관없이 상항 외부 조인을 사용

#### 코틀린에[서 프록시를 사용할 떄는 open이 설정되어 있어야 한다.
```kotlin
plugins{
    id("org.jetbrains.kotlin.plugin.allopen") version "1.4.30-RC"
}

allOpen {
	annotation("javax.persistence.Entity")
	annotation("javax.persistence.Embeddable")
	annotation("javax.persistence.MappedSuperclass")
}
```

상기 plugin 과 설정을 통해 대상 어노테이션을 사용하는 클래스가   
전부 open 되도록 설정할 수 있다.