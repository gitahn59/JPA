# 엔티티 비교

영속성 컨텍스트 내부에는 엔티티 인스턴스를 보관하는 1차 캐시가 존재한다.  
이는 영속성 컨텍스트와 생명주기를 같이 한다.   

양속성 컨텍스트를 통해 데이터를 저장하거나 조회하면 1차 캐시에 엔티티가 저장된다.    
이 1차 캐시 덕분에 변경 감지 기능이 동작하고, 1차 캐시로 사용되어 DB를 조회하지 않고 데이터를 바로 조회할 수도 있다.    

영속성 컨텍스트를 더욱 자세히 이해하기 위해서는 1차 캐시의 가장 큰 장점인 애플리케이션 수준 반복 가능한 읽기를 이해해야 한다.   
같은 영속성 컨텍스트에서 엔티티를 조회하면 항상 같은 엔티티 인스턴스를 반환한다.   
이는 단순히 동등성(equals) 비교 수준이 아니라 정말로 주소값이 같은 인스턴스를 반환한다는 것이다.   

## 영속성 컨텍스트가 같을 때의 엔티티 비교

테스트의 경우 테스트의 범위는 다음과 같다.

요청 -> Test -> Service -> Repository (영속성 컨텍스트는 전범위에 걸쳐서 생존)

이 경우 테스트 속에서 엔티티는 항상 같은 영속성 컨텍스트에 의해 조회된다.  
따라서 1차 캐시를 통해 조회되기 때문에 같은 엔티티를 조회하면 같은 인스턴스가 조회된다.    

이에 따라 3가지 동등성을 만족한다.
* 동일성 : 참조 비교가 같다 => 주소가 같다.
* 동등성 : equals() 비교가 같다 => 필드값이 같다.
* 데이터베이스 동등성 : @Id인 식별자가 같다.    

## 영속성 컨텍스트가 다를 때의 엔티티 비교

서로 다른 영속성 컨텍스트에서 같은 엔티티를 조회하면 서로 다른 인스턴스를 돌려받게 된다.    

* 동일성 : 참조 비교가 다르다 => 주소가 다르다.
* 동등성 : equals() 비교가 같다 => 필드값이 같다.
* 데이터베이스 동등성 : @Id인 식별자가 같다.

이처럼 영소성 컨텍스트가 다르면 동일서 ㅇ비교는 실패하게 된다.

만약 영속성 컨텍스트틀 보장한다면 동일성 비교만으로도 충분하다.    
따라서 OSIV처럼 요청의 시작부터 끝까지 같은 영속성 컨텍스트를 사용한다면 동일성비교를 성공하게 된다.    
하지만 영속성 컨텍스트가 달라지면 동일성 비교는 실패한다.    
따라서 엔티티의 비교에 다른 방법을 사용해야 한다.    

데이터베이스 동등성 비교는 엔티티을 영속성해야 식별자를 얻을 수 있다는 문제가 있다.    
따라서 남은 것은 equals()를 사용한 동등성 비교인데, 엔티티를 비교할 때는 비즈니스 키를 활용한 동등성 비교를 권장한다.   

동등성 비교를 위해 equals()를 오버라이드 하여 비즈니스 키만 선택하여 비교하도록 하는 것이다.   
데이터베이스의 기본 키 후보들이 좋은 대상이다.   

