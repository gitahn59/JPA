# 성능 최적화
## N + 1 문제

JPA 애플리케이션에서 가장 큰 문제점은 N + 1 문제점이다.   

### 즉시 로딩과 N + 1

연관관계에 대해 전략을 즉시로딩으로 설정하면 SQL 을 두 번 실행하는 것이 아니라    
조인을 통해 한 번의 SQL 로 조회한다.   
이렇게 보면 즉시 로딩이 상당히 좋아보이지만 JPQL 을 사용할 때 문제가 발생한다.   

JPQL을 실행하면 JPA 는 이를 분석해서 SQL 을 생성한다.   
즉시 로딩이 설정 된 엔티티가 있으면 JPA 는 JPA는 주문 컬렉션을 즉시 로딩하려고 SQL을 추가로 실행한다.   
이는 연관 엔티티의 수 만큼 실행되며 5개가 있으면 5번이 실행된다.   

### 지연 로딩과 N + 1

즉시 로딩을 지연 로딩으로 변경해도 N + 1 문제에서 자유로울 수는 없다.   
지연 로딩으로 설정하면 JPQL 에서는 N + 1 문제가 발생하지는 않는다.   
이후 비즈니스 로직에서 그 엔티티를 직접 접근할 때 지연 로딩이 발생한다.  
이것 역시 마찬가지로 엔티티의 수 만큼 SQL 이 실행되며 N + 1 문제를 피할 수 없다.   

### 페치 조인 사용

N + 1 문제의 가장 일반적인 방법은 페치 조인을 사용하는 것이다.   
페치 조인은 SQL 조인을 사용해서 엔티티를 한번에 조회하므로 N + 1 문제가 발생하지 않는다.
조인이 실행되기 때문에 JPQL 역시 엔티티의 개수만큼 생성되므로 DISTINCT 를 사용하면 중복을 제거한 결과를 받을 수 있다.   

### 하이버네이트 @BatchSize

하이버네이트가 제공하는 @BatchSize 를 사용하면    
연관된 엔티티를 조회할 때 지정한 만큼의 IN 절을 사용 해서 조회한다.   

```kotlin
@Entity
class Member(
    ...
    @BatchSize(size = 5)
    @OneToMany(mappedBy = "member", fetch = FetchTytpe.EAGER)
    val orders = List<Order>
)
```

> IN 절에 식별자 값을 미리 넣어두고 한 번에 그 만큼 조회해서 가져욘다.     
> ex) 엔티티가 13개 있고 btachSize 가 3 이면 5개를 짤라서 가져온다.   

물론 Member를 findById를 통해 1개만 조회한다면,    
미리 생성된 쿼리를 사용하므로 join을 사용하여 N+1 문제는 발생하지 않으며 in 절을 사용하지 않는다.    

lazy 로딩으로 설정하고, list 에 대한 조회가 필요하면 where 식별자 = id 로 조회하므로 마찬가지로
N + 1 문제가 발생하지 않는다.    

하이버네이트가 만들지 않은 쿼리를 사용하는 경우는 findAll 같은 경우로 직접 JPQL 을 사용하는 경우이다.
이는 복수개의 Member를 조회할 때 발생하는 N + 1 그 문제가 발생할 것이며 이 경우에만 in 절을 사용하게 된다.   

### 하이버네이트 @Fetch(FetchMode.SUBSELECT)

@Fetch(FetchMode.SUBSELECT) 로 사용하면 연관된 데이터를 조회할 때 서브 쿼리를 사용해서 N + 1 문제를 해결한다.       
즉시로딩이라면 즉시 로딩 시점에, 지연 로딩이라면 프록시를 사용하는 시점에 서브쿼리가 실행된다.

### N + 1 정리

기본적으로 지연 로딩을 사용한다.   
그리고 성능 최적화가 꼭 필요한 곳에 JPQL 페치 조인을 사용해야 한다.  

## 읽기 전용 쿼리의 성능 최적화    

엔티티가 영속성 컨텍스트에서 관리된다면 1차 캐시부터 변경 감지까지 얻을 수 있는 이득이 많다.    
하지만 영속성 컨텍스트는 변경 감지를 위해 스냅샷 인스턴스를 보관해야 하므로 더 많은 메모리를 사용한다는 단점이 있다.    
100건의 구매 내용을 출력하는 단순 조회 화면이 있다고 가정해보자.    
엔티티를 다시 조회할 일도 없고 수정할 일도 없이 딱 한 번만 읽어서 화면에 출력하면 된다.    
이떄는 읽기 전용으로 엔티티를 조회하면 메모리 사용량을 최적화 할 수 있다.   

### 스칼라 타입으로 조회

엔티티가 아닌 스칼라 타입으로 모든 필드를 조회하면 영속성 컨텍스트가 관리하지 않으므로 최적화된다.    

### 읽기 전용 쿼리 힌트 사용

하이버네이트 전용 힌트인 org.hibernate.readOnly를 사용하면 엔티티를 읽기 전용으로 조회한다.   
읽기 전용이기 때문에 영속성 컨텍스트 스냅샷에 보관되지 않으므로 메모리 사용량을 최적화할 수 있다.   
또한 스냅샷이 없으므로 엔티티를 수정하더라도 변경이 감지되지 않아 데이터베이스에 반영되지도 않는다.    

### 읽기 전용 트랜잭션 사용

스프링 프레임워크를 사용한다면 읽기 전용 모드를 사용할 수 있다.   
@Transactional(readOnly = true)

이러한 옵션을 설정하면 스프링 프레임워크는 하이버네이트 세션의 플러시 모드를 MANAUL로 설정한다.   
이 경우 강제로 플러시를 호출하지 않는다면 플러시가 일어나지 않는다.    
따라서 트랜잭션을 커밋하더라도 영속석 컨텍스트를 플러시하지 않는다.   

영속성 컨텍스트를 플러시하지 않으므로 수정 삭제는 당연히 동작하지 않는다.    
또한 플러시할 떄 일어나는 스냅샷 비교와 같은 무거운 로직들을 수행할 필요가 없으므로 성능이 향상된다.   
물론 트랜잭션은 시작했으므로 트랜잭션 시작, 로직수행, 커밋의 과정은 이루어진다.   
단지 영속성 컨텍스트를 플러시하지 않을 뿐이다.   

### 트랜잭션 밖에서 읽기

트랜잭션 밖에서 읽는다는 것은 트랜잭션 없이 엔티티를 조회한다는 의미이다.    
JPA에서는 데이터를 변경하려면 트랜잭션은 필수다.    
따라서 조회가 목적인 경우에만 이 기능을 사용해야 한다.    

@Transactional(propagation = Propagation.NOT_SUPPORTED)

이렇게 트랜잭션을 사용하지 않는다면 플러시가 일어나지 않으므로 조회 성능이 향상된다.    

기본적으로 플러시 모드는 AUTO로 설정되어있다.    
따라서 트랜잭션을 커밋하거나 쿼리를 실행하면 플러시가 작동한다.    
그런데 트랜잭션 자체가 존재하지 않으므로 트랜잭션을 커밋할 일이 없어진다.    
그리고 JPQL 쿼리도 트랜잭션 없이 실행한다면 플러시를 호출하지 않는다.    

읽기 전용 데이터를 조회할 때, 메모리를 최적화하려면 스칼라 타입으로 조회하거나 하이버네이트가 제공하는 일기 전용 쿼리 힌트를 사용하면 된다.    
플러시 호출을 막아서 속도를 최적화하려면 읽기 전용 트랜잭션을 사용하거나    
트랜잭션 밖에서 읽기를 사용하면 된다.    
(스프링을 사용한다면 읽기 전용 트랜잭션을 사용하는 것이 편리할 것이다.)    

## 배치 처리

대량의 데이터를 배치 처리해야 하는 경우, 일반적인 방식으로 엔티티를 계속 조회하면 컨텍스트에 많은 엔티티가 쌓이며 메모리 초과가 발생한다.   
따라서 이러한 배치 처리는 적절한 단위로 영속성 컨텍스트를 초기화할 필요가 있다.

### JPA 등록 배치

수만 건 이상의 엔티티를 한 번에 등록할 때 주의할 점은 영속성 컨텍스트에 엔티티가 계속 쌓이지 않도록   
일정 단위마다 영속성 컨텍스트의 엔티티를 데이터베이스에 플러시하고 영속성 컨텍스트를 초기화해야 한다.   
등록 배치는 이렇게 해결할 수 있다.

### 수정 배치 처리
배치 처리는 아주 많은 데이터를 조회해서 수정한다.   
이때 수많은 데이터를 한번에 메모리에 올릴 수 없어 2가지 방법을 주로 사용한다.

#### (1) JPA 페이징 배치 처리
페이징을 이용하면 한 번에 N 건식 원하는 만큼 엔티티를 읽어올 수 있다.   
페이지 단위마다 영속성 컨텍스트를 플러시하고 초기화한다.   

#### (2) 하이버네이트 scroll 사용
하이버네이트는 scroll 이라는 이름으로 JDBC 커서를 지원한다.   

#### (3) SQL 쿼리 힌트 사용
JPA 는 데이터베이스 SQL 힌트 기능을 제공하지 않는다.   
따라서 하이버네이트를 직접 사용해야 한다.   

SQL 힌트는 하이버네이트 쿼리가 제공하는 addQueryHint() 메소드를 사용한다.   


## 트랜잭션을 지원하는 쓰기 지연과 성능 최적화

트랜잭션을 지원하는 쓰기 지연을 확용하면 애플리케이션 선응을 최적화할 수 있다.   
SQL을 직접사용하는 경우 매번 데이터베이스와 통신하게 된다.   
이를 최적화하려면 SQL을 모아서 한 번에 데이터베이스로 보내면 된다.   

JDBC가 제공하는 SQL 배치 기능을 사용하면 SQL을 모아서 데이터베이스에 한 번에 보낼 수 있다.   
하지만 이러한 기능을 사용하려면 코드의 많은 부분을 수정해야한다.   
특히 비즈니스 로직이 복잡하게 얽혀 있는곳에서는 사용하기 쉽지않고, 적용하더라도 코드가 지저분해진다.   

JPQ는 플러시 기능이 있으므로 SQL 배치 기능을 효과적으로 사용할 수 있다.   
SQL 배치 최적화 전략은 구현체마다 조금씩 다르다.    
하이버네이트에서는 SQL 배치를 적용하려면 다음과 같이 설정한다.   

<property name="hibernate.jdbc.batch_size" value = "50"/>

```kotlin
em.persist(Member()) // 1
em.persist(Member()) // 2
em.persist(Member()) // 3
em.persist(Child()) // 다른 연산
em.persist(Member()) // 4
em.persist(Member()) // 5
```

SQL 배치 기능은 같은 SQL일 경우에만 유효하다.   
중간에 다른 SQL이 들어가면 SQL 배치는 따로 시작하여 같은 연산끼리 나누어서 사용한다.    
위의 경우 (1,2,3), 다른연산 (4,5) 로 나누어져서 실행된다.   

> 엔티티가 영속 상태가 되려면 식별자가 꼭 필요하다.    
> 그런데 IDENTITY 식별자 생성 전략은 엔티티를 데이터베이스에 저장할 때 알 수 있으므로   
> 영속시 즉시 INSERT SQL이 데이터베이스에 전달된다.   
> 따라서 쓰기 지연을 활용한 성능 최적화를 할 수 없다.   

## 트랜잭션을 지원하는 쓰기 지연과 애플리케이션 확장

트랜잭션을 지원하는 쓰기 지연과 변경 감지기능을 사용할 수 있다면 선으의 향상을 가져올 수 있다.   
특히 데이터베이스의 테이블 로우에 걸리는 락을 최소화 할 수 있다.    

이 기능은 트랜잭션을 커밋해서 영속성 컨텍스트를 플러시하지 전까지는    
데이터 베이스에 데이터를 등록, 수정, 삭제하지 않는다.    
따라서 커밋 직전까지 데이터베이스 로우에 락을 걸지 않는다.   

JPA를 사용하지 않고 SQL을 직접 다루면 update(memberA)를 호출할 때    
UPDATE SQL을 실행하면서 데이터베이스 테이블에 락을 건다.    
이 락은 비즈니스 로직을 전부 수행하고 commit()을 호출할 때까지 유지된다.   

트랜잭션 격리 수준에 따라 다르지만, 
일반적으로 사용하는 커밋된 읽기 격리 수준 그 이상에서는    
데이터베이스에 현재 수정 중인 데이터를 수정하려는 다른 트랜잭션은 락이 풀릴 때까지 대기한다.   

JPA는 커밋을 해야 플러시를 호출하고 데이터베이스에 수정 쿼리를 보낸다.
쿼리를 보내고 바로 트랜잭션을 커밋한다면 결과적으로 데이터베이스에 락이 걸리는 시간을 최소화 할 수 있다.    

이러한 JPA의 쓰기 지연 기능은 데이터베이스에 락이 걸리는 시간을 최소화해서 동시에 더 많은    
트랜잭션을 처리할 수 있는 장점이 있다.    
