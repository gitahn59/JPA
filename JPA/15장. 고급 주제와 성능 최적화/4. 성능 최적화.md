# 성능 최적화
## N + 1 문제
JPA 애플리케이션에서 가장 큰 문제점은 N + 1 문제점이다.   

### 즉시 로딩과 N + 1
연관관계에 대해 전략을 즉시로딩으로 설정하면 SQL 을 두 번 실행하는 것이 아니라    
조인을 통해 한 번의 SQL 로 조회한다.   
이렇게 보면 즉시 로딩이 상당히 좋아보이지만 JPQL 을 사용할 때 문제가 발생한다.   

JPQL을 실행하면 JPA 는 이를 분석해서 SQL 을 생성한다.   
즉시 로딩이 설정 된 엔티티가 있으면 JPA 는 JPA 는 주문 컬렉션을 즉시 로딩하려고 SQL을 추가로 실행한다.   
이는 연관 엔티티의 수 만큼 실행되며 5개가 있으면 5번이 실행된다.   

### 지연 로딩과 N + 1
즉시 로딩을 지연 로딩으로 변경해도 N + 1 문제에서 자유로울 수는 없다.   
지연 로딩으로 설정하면 JPQL 에서는 N + 1 문제가 발생하지는 않는다.   
이후 비즈니스 로직에서 그 엔티티를 직접 접근할 때 지연 로딩이 발생한다.  
이것 역시 마찬가지로 엔티티의 수 만큼 SQL 이 실행되며 N + 1 문제를 피할 수 없다.   

### 페치 조인 사용
N + 1 문제의 가장 일반적인 방법은 페치 조인을 사용하는 것이다.   
페치 조인은 SQL 조인을 사용해서 엔티티를 한번에 조회하므로 N + 1 문제가 발생하지 않는다.   

조인이 실행되기 때문에 JPQL 역시 엔티티의 개수만큼 생성되므로 DISTINCT 를 사용하면 중복을 제거한 결과를 받을 수 있다.   

### 하이버네이트 @BatchSize
하이버네티느가 제공하는 @BatchSize 를 사용하면    
연관된 엔티티를 조회할 때 지정한 만큼의 IN 절을 사용 해서 조회한다.   

> IN 절에 식별자 값을 미리 넣어두고 한 번에 그 만큼 조회해서 가져욘다.     
> ex) 엔티티가 13개 있고 btachSize 가 3 이면 5개를 짤라서 가져온다.   

### 하이버네이트 @Fetch(FetchMode.SUBSELECT)

@Fetch(FetchMode.SUBSELECT) 로 사용하면 연관된 데이터를 조회할 때 서브 쿼리를 사용해서 N + 1 문제를 해결한다.       
이 어노테이션을 사용하면 SUB 쿼리를 사용해서 조회를 실행한다.

### N + 1 정리
기본적으로 지연 로딩을 사용한다.   
그리고 성능 최적화가 꼭 필요한 곳에 JPQL 페치 조인을 사용해야 한다.  


## 배치 처리
대량의 데이터를 배치 처리해야 하는 경우, 일반적인 방식으로 엔티티를 계속 조회하면 컨텍스트에 많은 엔티티가 쌓이며 메모리 초과가 발생한다.   
따라서 이러한 배치 처리는 적절한 단위로 영속성 컨텍스트를 초기화할 필요가 있다.   

### JPA 등록 배치
수만 건 이상의 엔티티를 한 번에 등록할 때 주의할 점은 영속성 컨텍스트에 엔티티가 계속 쌓이지 않도록   
일정 단위마다 영속성 컨텍스트의 엔티티를 데이터베이스에 플러시하고 영속성 컨텍스트를 초기화해야 한다.   
등록 배치는 이렇게 해결할 수 있다.

### 수정 배치 처리
배치 처리는 아주 많은 데이터를 조회해서 수정한다.   
이때 수많은 데이터를 한번에 메모리에 올릴 수 없어 2가지 방법을 주로 사용한다.

#### (1) JPA 페이징 배치 처리
페이징을 이용하면 한 번에 N 건식 원하는 만큼 엔티티를 읽어올 수 있다.   
페이지 단위마다 영속성 컨텍스트를 플러시하고 초기화한다.   

#### (2) 하이버네이트 scroll 사용
하이버네이트는 scroll 이라는 이름으로 JDBC 커서를 지원한다.   

#### (3) SQL 쿼리 힌트 사용
JPA 는 데이터베이스 SQL 힌트 기능을 제공하지 않는다.   
따라서 하이버네이트를 직접 사용해야 한다.   

SQL 힌트는 하이버네이트 쿼리가 제공하는 addQueryHint() 메소드를 사용한다.   

